### 数组

#### 定义

同其他语言一样，数组是定义在连续的内存地址上、元素类型一致、空间大小在创建以后就固定的一组连续数据。不同长度的数组，即使保存的元素类型一致，也会被任务是不同的类型。

#### 数组的创建

arr := [10]int{} 或者 var arr [10]int 

**不能通过make创建**，**不能通过变量长度创建**

通过make创建的是slice，变量长度会编译失败。



### Slice

slice是以数组为基础的数据类型，其类型规范为[]T,其中T为slice中的元素类型。

#### 创建方法

可以通过不指定长度创建slice

`s := []int{1,2,3}`

或者通过make创建

`s := make([]int,3)`

或者通过slice或者数组进行创建

`s := arr[:1]`



#### slice的属性

假设，原数组为arr := []int{0,1,2,3,4,5,6,7,8,9},slice为s := arr[1:4]

##### data

指向引用数组元素位置的指针，s的data指向的就是arr[1]的指针。

##### len

是引用数组元素起始位置到**引用结束位置**的长度，s的len = 3,等于元素1至末尾元素3的长度。

##### cap

是引用数组元素起始位置到**数组结束位置**的长度，s的cap = 9，等于元素1至末尾元素9的长度。



#### 如何扩容

当slice进行append，且cap不够时，程序会自动创建一个新的底层数组，将老的数组数据copy到新的数组上，并将slice指向新的数组。

oldCap：扩容前容量

oldLen：扩容前元素个数

cap：扩容所需最小容量

newCap：预估容量

（1）如果扩容前的容量翻倍之后还是小于所需最小容量，那么预估容量就等于所需最小容量。

（2）如果不满足第一条，而且扩容前容量小于1024，那就直接翻倍没商量。

（3）如果不满足第一条，而且扩容前容量大于等于1024，那就循环扩容四分之一，直到大于等于所需最小容量。

**注意：，不同的go版本的扩容规则有所不同，在1.16中，和1024比较的不是oldLen了，而是oldCap。在1.18中，不再和1024比较，而是与256比较**