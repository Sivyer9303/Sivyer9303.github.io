## 垃圾回收算法

### 可达性算法

如何标记一个对象是否可以进行回收？常见的有两种，引用计数法和可达性算法，引用计数法比较简单，通过给每个对象添加一个引用计数器，当出现引用时，将计数器加一即可，但是引用计数法无法处理循环依赖的问题，因此目前主流的垃圾回收收集器都是采用可达性算法来进行对象是否可回收的判定。

#### 算法思想

可达性算法的主要思想是，使用一些对象作为根节点（GC ROOT），从根节点一步步向下搜索，搜索的路径称为引用链，当某个对象不在任意一条引用链上时，则表示这个对象不可达，则会被标记为需要清除的对象。

#### GC ROOT

作为可达性算法的起点，GC ROOT至关重要，所以需要采用一些比较重要或者无法变动的对象作为节点。

GCROOT可以使用以下几种对象：

##### 1.虚拟机栈(栈帧中的本地变量表)中引用的对象

   当某个对象是在方法调用时出现的局部变量，且该方法仍然处于栈帧中，则其局部变量可以作为根节点，所有局部变量引用链上的对象都不会被标记。

   例如,如下代码中，存在method方法，method方法显示调用System.gc()，但是由于method方法仍然处于栈帧中，t变量不会被回收，将作为GC ROOT进行可达性标记。若method方法执行完成，后续有其他地方再次触发GC，则method方法因为已经不在栈帧当中，则t变量会被进行回收（因为是局部变量，已不可达）。

```java
public static void method() {
    Test t = new Test();
    System.gc();
    System.out.println("GC done");
}
```

##### 2.本地方法栈(Native 方法)中引用的对象

   同虚拟机栈中引用的对象一样，本地方法栈中引用的对象也可以作为GC ROOT。

##### 3.方法区中类静态属性引用的对象

   当某个对象为静态对象（被static修饰），则它不会被minorGC或fullGC所回收，它的最终归宿就在老年代中，因此这一类对象可以理解为永远不会消失的，可以作为GCROOT。

##### 4.方法区中类常量引用的对象

  当某个对象为常量（被static final修饰），则它本身就是不会变更的，会永远存在，同样也可以作为GCROOT。

##### 5.所有被同步锁持有的对象

  当某个代码块被同步锁给锁住，则该代码块中的所有对象，都应该是不能被回收的，因此代码块中的所有对象都可以作为GCROOT。

##### GC ROOT所涉及的内存区域

综合上面的五种GCROOT，在jvm内存区域中，会有以下几个区域与此相关。

1.虚拟机栈：虚拟机栈中用于存储线程的调用栈，栈帧中的本地变量表是决定是否对象可以作为GCROOT的依据。

2.本地方法栈：同虚拟机栈。

3.方法区：方法区中的运行时常量池中，会存在类常量，因此也会涉及。

4.堆：同步锁持有的对象可能在堆中。



#### 标记-复制算法

标记算法将内存空间分为两个部分，from和to区两个部分。

当jvm运行时，只会使用其中一个部分，也就是from区，当from区满了以后，将from区中的对象进行可达性分析，标记需要清除的对象，标记完成后，将不需要清除的对象迁移至to区中，将from区清空，最后旧的to区作为新一轮的from区，旧的from区作为新的to区。

**优点：效率高，内存连续度高，不会出现内存碎片。**

**缺点：内存使用率不高，因为运行时，都只能使用一半的内存空间。**

//TODO 添加图片

#### 标记-清除算法

标记清除算法非常简单粗暴，在内存空间满了以后，将内存中的对象进行可达性标记，标记完成以后，将所有不需要保留的对象全部清除。

**优点：最基础的算法，算法简单。**

**缺点：容易产生内存碎片，导致无法放入大对象。标记和清除的过程效率都不算高。**

//TODO 添加图片

#### 标记-整理算法

因为前面两种算法仍然存在可优化空间，因此标记-整理算法出现了，标记-整理算法比较适用于老年代中，主要分为标记和整理两个步骤，在标记完成以后，将存活下来的对象迁移到同一侧，然后清除所有边界以外的对象，因此是不会产生内存碎片的。

//TODO 添加图片

#### 分代收集思想

在jvm堆中，存在新生代和老年代，因为两代的特性不太一样，为了保证垃圾回收更加合理且高效，HotPot虚拟机大部分收集器都采用了分带收集的思想，在新生代中使用标记-复制算法，在老年代中使用标记-整理算法或者标记-清除算法。



### 参考资料

https://blog.csdn.net/u010798968/article/details/72835255

https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md
