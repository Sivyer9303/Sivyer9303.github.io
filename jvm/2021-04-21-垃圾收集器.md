## 垃圾收集器

如果说收集算法是内存回收的方法论，那垃圾收集器就是内存回收的实践者。

下面是常用垃圾收集器的组合图，连线表示可以混合使用。

![标记-复制](./垃圾收集器.jpg)

根据垃圾回收器的出现时间，可以分为经典垃圾收集器和低延迟垃圾收集器两大类，经典垃圾收集器以CMS、G1为核心代表，低延迟垃圾收集器以ZGC为核心代表。

### 相关术语解释

STW - stop the world,垃圾收集器在进行收集时，需要停顿用户线程，这种现象称为stop the world，简称STW。

吞吐量 - 是用户代码运行时间除以用户代码运行时间加上垃圾收集时间得出的比值。

### 经典垃圾收集器

经典垃圾回收器是指在JDK7之后、JDK11之前的这一类垃圾回收器。

#### 新生代收集器

新生代收集器主要有Serial、ParNew、Parallel Scavenge三种。

##### Serial收集器

Serial是最经典的垃圾收集器，它的特点很鲜明，就是在进行垃圾收集时，必须暂停所有的用户线程，直到收集器工作完成。

Serial收集器的工作流程如下图所示（老年代使用Serial Old），在进行垃圾收集时，可以看到用户线程全部停止,使用标记-复制算法进行垃圾收集。

![标记-复制](./Serial收集器.jpg)

优点：简单、高效，内存占用很小，对于单核或者核心数量较少的处理器，没有线程交互的开销。

缺点：STW（stop the world）时间长，若堆内需要回收的对象很多，GC线程会占用很长时间。

在当前微服务的趋势下，单个系统的内存如果不大，Serial收集器其实不失为一个很好的选择，因为在内存小的情况下，STW的时间并不会太长。

##### ParNew收集器

是Serial的多线程版本，同样在垃圾收集期间需要暂停所有用户线程，使用多线程进行垃圾收集，相关参数与Serial基本共用，在实现逻辑上也是与Serial相同的。

ParNew与Serial Old结合使用的示意图如下，ParNew在新生代中使用标记-复制算法。

![标记-复制](./ParNew.jpg)

在JDK9之前，得益于其是能够与CMS收集器一起使用的唯一一种收集器，因此，在JDK9之前是比较主流的新生代收集器。

ParNew收集器在单核心处理器的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程（Hyper-Threading）技术实现的伪双核处理器环境中都不能百分之百保证超越Serial收集器。当然，随着可以被使用的处理器核心数量的增加，ParNew对于垃圾收集时系统资源的高效利用还是很有好处的。它默认开启的收集线程数与处理器核心数量相同，在处理器核心非常多（譬如32个，现在CPU都是多核加超线程设计，服务器达到或超过32个逻辑核心的情况非常普遍）的环境中，可以使用-XX：ParallelGCThreads参数来限制垃圾收集的线程数。

##### Parallel Scavenge收集器

Parallel Scavenge收集器在收集方式上与ParNew如出一辙，但是相比于ParNew、CMS这种以减少STW时间的收集器不同，Parallel Scavenge收集器的目标是提高吞吐量。

Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。

-XX：MaxGCPauseMillis - 设置垃圾收集所允许的停顿时间，如果设置的过小，虽然单次收集的停顿时间变短，但是GC的次数会增加，导致吞吐量实际上会下降。

-XX：GCTimeRatio - 垃圾收集时间占总时间的比例，与吞吐量成反比，GCTimeRatio值越大，表示垃圾收集的时间占比越大，则吞吐量下降。可选值为0-100.

-XX：+UseAdaptiveSizePolicy - 自动调整策略，设置开启此策略以后，新生代大小、Eden区大小、survivor区大小、新生代年龄等参数均会自动按照当前系统的运行信息进行自动调整，虚拟机会根据上面的XX：MaxGCPauseMillis 和XX：GCTimeRatio参数所设置的目标，尽可能的优化当前虚拟机的运行。

##### 

#### 老年代收集器

##### Serial Old收集器

Serial收集器的老年代版本，使用单线程进行垃圾收集，在垃圾收集期间，需要暂停所有的用户线程。

其收集方式与Serial收集器一致，使用标记-整理算法进行垃圾收集。

![标记-复制](./Serial收集器.jpg)

Serial Old通常与Parallel Scavenge收集器一起使用，Serial Old有个特殊的地方在于，它会作为CMS的备选，当CMS出现并发失败时（详见后面的CMS收集器），虚拟机会采用Serial Old进行替换使用。

##### Parallel Old收集器

Parallel Scavenge收集器的老年代版本，同样以提高系统吞吐量为目标，基于标记-整理算法实现。

![标记-复制](./parallel Old.jpg)

Parallel Old只能与Parallel Scavenge搭配使用。

##### CMS收集器

CMS全程为Concurrent Mark Sweep，使用的算法是标记-清除算法，通过并发标记，尽可能减少用户停顿时间。

CMS收集的流程主要分为四步：

1.初始标记 - 标记一下GCROOT能够直接关联的对象，会STW，但是因为标记的对象不多，所以暂停的时间很短。

2.并发标记 - 遍历整个对象图，可以与用户线程并行，不会造成STW。

3.重新标记 - 处理并发标记过程中，用户线程修改引用的对象，使用增量更新的手段处理并发可达性分析。这个阶段会暂停用户线程，但是时间会比并发标记短很多。

4.并发清除 - 将已经死掉的对象进行清除，因为使用的是标记-清除算法，所以在清除过程中不会对用户线程造成影响，因此可以和用户线程并行。

![标记-复制](./cms.jpg)

优点：作为并发收集器，它的最大优点是大部分时间可以和用户线程并行，停顿时间短。

**缺点**：1.对系统处理器资源敏感，因为会和用户线程并行，导致在并发标记或者并发清除时，会占用系统处理器资源，变相的导致了吞吐量的降低，CMS默认启动的回收线程数是（处理器核心数量+3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大，因为此时回收线程的数量占比会很大。

​	   2.无法处理“浮动垃圾”，在进行并发标记和并发清除过程中，为了保证用户线程的正常运行，需要预留内存空间给用户线程使用，因此，与其他收集器在老年代满的时候才进行GC不同，CMS在老年代的内存达到一定阈值就会开始垃圾收集，这也导致了一个问题，预留多少内存才合适，如果在进行垃圾收集的过程中，预留的内存无法满足新对象的分配，则会触发“并发失败”,虚拟机会使用Serial Old来作为备选方案进行垃圾收集，可以通过-XX：CMSInitiatingOccupancyFraction参数来设置启动垃圾收集的阈值，它是一个百分比的值。

​	   3.内存碎片问题，因为使用的是标记-清除算法，导致在垃圾收集结束以后，出现很多内存碎片，无法处理一些比较大的对象，此时很有可能明明还有足够的内存，但只能通过触发GC来再次清理。



#### G1收集器

不同于上述其他收集器，G1收集器不是针对于具体某个代的，而是针对于整个堆的，将堆分成若干个Region，可以针对局部进行垃圾收集。

在G1出现之前，所有的收集器要么针对新生代进行收集（minorGC），要么针对老年代进行收集（MajorGC），要么对整个堆进行收集（Full GC），G1是以Region为单位进行收集，需要进行收集的Region会组成回收集（Collection Set，简称CSet），衡量Region是否需要收集的标准不再是其是否属于某个代，而是哪个Region中的垃圾数量最多，回收的收益最大，此类GC模式也称为MixedGC。

##### G1收集器下的内存布局

在使用G1收集器时，虚拟机会将内存分为若干个Region区域，每个Region都可以根据需要扮演新生代Eden、新生代Survivor、老年代，在进行垃圾收集时，可以根据Region扮演角色的不同，使用不同的策略进行收集。

当出现超过单个Region大小一半的大对象时，会将大对象分配到一类称为Humongous的Region区域中，若对象超过单个Region大小，还可以通过组合N个连续的Humongous区域来进行存储。

![标记-复制](./g1.jpg)

G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。

##### G1收集优先级

为了达到用户所设置的停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），G1在收集时，会优先考虑回收价值大的Region，评估回收价值是通过判断Region中脏卡表的数量、Region回收耗时等条件来进行评估。

##### G1收集步骤

![标记-复制](./g1运行示意图.jpg)

主要分为四个步骤：

1.初始标记 - 标记GCROOT能够直接关联到的对象，并修改TAMS（Top at Mark Start）指针的值，这个阶段需要暂停用户线程，G1借用MinorGC进行初始标记，因此不需要额外的停顿时间。

2.并发标记 - 遍历整个对象图，标记需要收集的对象，基于原始快照的方式解决并发标记的问题。（详见并发可达性分析），同样有可能造成并发失败，进而退化成Serial Old或者Serial。

3.最终标记 - 处理在并发标记阶段，用户线程所遗留的对象。

4.筛选回收 - 更新每个Region的统计数据，按照Region回收价值和回收成本进行排序，根据用户制定的停顿时间来制定回收计划，可以选择若干个Region组成回收集，将需要保留的对象迁移至新的空Region，然后清除掉原来的Region。这个阶段涉及对象的移动，因此会暂停用户线程。

##### 跨代引用问题

G1采用的解决方式是卡表，每个Region会维护一个自己的卡表，记录着所有指向当前Region的对象的指针，并标记这些指针指向的对象在哪些卡页中。

因为每个Region都有维护自己的卡表，这导致G1在内存占用上会比其他收集器更高，大概需要整个堆内存的10%-20%左右的空间来维持收集器的工作。

##### 与CMS的对比

G1与CMS对比有以下特点：

1.G1采用的是标记-整理、标记-复制算法，相较于CMS的标记-清除，不容易产生内存碎片。

2.G1采用分Region的垃圾收集，单次收集收益更大。

3.G1可以指定最大停顿时间。

4.G1占用的系统内存比CMS大很多。

5.G1使用原始快照的方式进行并发标记，同时因为每个Region都维护了卡表，G1需要在写前屏障中跟踪并发指针的变化，在写后屏障中，和CMS一样，也需要更新卡表。相较于CMS来说，G1的操作会更多且更复杂，因此G1在进行处理时，采用的是类似于消息队列的方式来进行异步处理。



### 低延迟收集器

各收集器的对比：

![标记-复制](./3-14.jpg)

#### ZGC

ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。

##### ZGC的内存布局

与G1类似，使用Region内存布局，但不同之处在于，ZGC的Region大小不是固定的，ZGC的Region主要由三种大小的，

1，小型Region，大小为4M，用于存储小于256KB的小对象。

2，中型Region，大小为32M，用于存储大小在256KB到4M之间的对象。

3，大型Region，大小不固定，但是肯定是2M的整数倍，每个大型Region只会存放一个大对象。

![标记-复制](./zgcRegion.jpg)

##### 并发整理实现的关键思想

经典垃圾收集器在进行回收整理的时候，不可避免的需要暂停用户线程，而低延迟收集器Shenandoah和ZGC在并发整理时，分别使用了转发指针和染色指针的方式来实现并发整理，以达到更低的延时。

染色指针：以Linux为例，在64位系统下，一个指针的长度有64位，最高的18位不能用来寻址，除去这18位，仍然还有46位指针，ZGC将46位的前4位剥离出来，用来当做标志位，虚拟机可以直接从指针中看到其引用对
象的**三色标记状态、是否进入了重分配集（即被移动过）、是否只能通过finalize()**方法才能被访问
到。因为指针位数的缩小，导致ZGC最高能够管理的堆内存只有2的42次幂，也就是4TB大小。

![标记-复制](./染色指针.jpg)

多重映射：染色指针会污染指针的四位，为了将被污染的后的指针仍然能够正确的对象，ZGC使用多重映射来解决这个问题，假设现在有个对象的物理地址为0x0000000012345678，那么相对应的，0x0000040012345678、0x0000080012345678、0x0000100012345678等这些携带标识的指针，同样也应该指向同一个对象，ZGC通过创建0x0000040012345678、0x0000080012345678、0x0000100012345678这些虚拟地址，将这些地址指向真正对象的物理地址，以达到多个虚拟地址指向同一个物理地址的效果。

转发表：并发整理时，每个Region会记录原来属于当前Region，后被迁移到其他Region中的对象的新旧指针。

指针自愈：当对象在并发整理时，存活的对象可能会被迁移到其他空的Region中，但是与此同时，用户线程仍然在运行，为了让用户线程能够争取的获取到对象，ZGC使用了内存屏障，在进行真正访问时，会先染色指针上的“是否进入了重分配集”的标识，如果标识为真，则表示该对象已经被迁移走了，那么在真正访问前，会先从原来的Region中读取转发表，获取到迁移后的新地址，然后修改读取对象的地址为新地址，同时将“是否进入了重分配集”标识置为假。

##### ZGC的收集步骤

![标记-复制](./zgc.jpg)

ZGC的垃圾收集步骤主要分为四步

1.并发标记 - 与G1类似，包括初始标记、并发标记、最终标记等，但是ZGC的标记，是通过修改指针上的标志位来实现的。

2.并发预备重分配 - 扫描所有的Region，根据特定的规则进行Region的收集，组成重分配集，位于重分配集下的存活对象，会被复制到其他空的Region中，然后重分配集下的Region会被清除。

3.并发重分配 - 上一步获取到的重分配集，在这一步中会进行真正的重分配，每个需要重分配的Region维护一个转发表，用于用户线程访问对象时进行转发。

4.并发重映射 - 得益于指针自愈，在访问重分配之后的对象时，指针会进行修改，指向真正的对象，但是如果在两次GC的间隔中，没有访问过的重分配对象，它的指针不会变化，因此，为了保证指向的正确性，在下一次GC的并发标记时，扫描所有对象的同时，也会将对象的指针进行“自愈”，节省了一次遍历对象的开销。



### 一些感悟和总结

低延迟收集器主要解决的问题是在标记完成后，进行对象整理阶段的并发问题，因为G1使用的标记-整理算法，这一步骤必须暂停用户线程，进而导致G1这一步无法并发。（CMS因为使用的是标记-清除算法，所以可以并发）。

| 新生代收集器                                                 | 老年代收集器                                                 | 混合收集器                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Serial - 单线程，任何操作都需要暂停用户线程                  | Serial Old - Serial的老年代版本                              | G1 - 同样有新生代和老年代的概念，但是内存是按照Region来划分的，划分Region以后，可以将垃圾回收的范围缩小，但是仍然无法避免进行对象整理时，需要暂停用户线程的问题。 |
| ParNew - Serial的多线程版本，同样任何操作都需要暂停用户线程，但是使用多线程进行加速 | Parallel Old - Parallel Scavenge的老年代版本                 | ZGC - 与G1一样，同样是根据Region来划分内存空间，但是Region不是固定大小。使用染色指针的方式，将对象的标记、对象的复制等操作变得可以和用户线程并行了。 |
| Parallel Scavenge - 与ParNew思路一致，但是目标是高吞吐量，而非少停顿时间 | CMS - 除了初始标记和重新标记两个阶段外，其他时候都不需要暂停，但是有一个致命缺点，使用的是标记-清除，容易产生内存碎片。 |                                                              |







### 参考资料

《深入理解Java虚拟机》





