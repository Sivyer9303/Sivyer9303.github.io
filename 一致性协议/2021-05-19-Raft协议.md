### 简介

Raft协议是在Paxos协议的基础上进行的优化和改造，Paxos协议只包含了**状态复制**这一部分，而Raft则添加了**Leader选举**。

Paxos在进行达成共识过程时，必须先明确Leader和Follower，如果Leader出现故障，则会导致失败，而Raft会在Leader出现故障时，进行Leader选举。



### 角色

在Raft协议中，节点可能的角色有Leader、Follower、Candicat三种。

1. Leader总统节点，负责发出提案
2. Follower追随者节点，负责同意Leader发出的提案
3. Candidate候选人，负责争夺Leader



### Leader选举流程

[Raft选举演示动态图](http://thesecretlivesofdata.com/raft/#election)

每个节点都有两个定时器，一个是与Leader之间的心跳定时器，定时向Leader（或Leader定时向所有其他节点发送）发送心跳，如果超过了定时器的间隔阈值，则Leader会被当前节点判定为失效。另一个是选举定时器，当在选举阶段出现无法选举出Leader时，节点会进入休眠，休眠时间在一个范围内随机，当休眠结束，再次发起选举。

#### 任期

每次选举都会有一个任期的标识，任期是单调递增的，当节点收到多个选举请求时，会将任期小的请求废弃。

#### 脑裂问题

当集群之间出现网络波动或者异常时，节点被分为了N个部分，每个部分之间能够互相联通，但是与其他部分无法联通，此时，除了Leader所在的部分，其他部分都会认为Leader出现了故障，因此每个部分都开始选举，此时就会出现每个部分都选举出来了一个Leader，当网络恢复时，整个集群就被分隔成了若干个部分。

解决方案：在选举Leader时，要求Leader获取到的选票数量超过集群节点数量的一半。



### 与Paxos对比

Paxos算法和Raft算法有显而易见的相同点和不同点。二者的共同点在于，它们本质上都是单主的一致性算法，且都以不存在拜占庭将军问题作为前提条件。二者的不同点在于，Paxos算法相对于Raft，更加理论化，原理上理解比较抽象，仅仅提供了一套理论原型，这导致很多人在工业上实现Paxos时，不得已需要做很多针对性的优化和改进，但是改进完却发现算法整体和Paxos相去甚远，无法从原理上保证新算法的正确性，这一点是Paxos难以工程化的一个很大原因。相比之下Raft描述清晰，作者将算法原型的实现步骤完整地列在论文里，极大地方便了业界的工程师实现该算法，因而能够受到更广泛的应用。同时Paxos日志的传输过程中允许有空洞，而Raft传输的日志却一定是需要有连续性的，这个区别致使它们确认日志传输的过程产生差异。

但其实从根本上来看，Raft的核心思想和Paxos是非常一致的，甚至可以说，Raft是基于Paxos的一种具体化实现和改进，它让一致性算法更容易为人所接受，更容易得到实现。由此亦可见，Paxos在一致性算法中的奠基地位是不可撼动的。



